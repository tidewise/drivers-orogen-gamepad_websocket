# frozen_string_literal: true

name "gamepad_websocket"

cxx_standard "c++17"

using_library "base-logging"
using_library "controldev"
using_library "jsoncpp", typekit: false

import_types_from "base"
import_types_from "gamepad_websocketTypes.hpp"
import_types_from "linux_gpios"
import_types_from "std"

import_types_from "controldev/RawCommand.hpp"

task_context "GamepadCommandAggregatorTask" do
    needs_configuration

    property "device_name", "/std/string"
    # All gpios that make up the gamepad
    input_port "gpios_command", "/linux_gpios/GPIOState"
    input_port "joystick1_command", "/controldev/RawCommand"
    input_port "joystick2_command", "/controldev/RawCommand"

    # All gamepad commands aggregated as one RawCommand
    output_port "aggregated_command", "/controldev/RawCommand"

    port_driven
end

# Sets up a websocket serving the given endpoint at the given port
task_context "BaseWebsocketPublisherTask" do
    needs_configuration

    # The port to serve the websocket
    property "port", "uint16_t"

    # The endpoint pointing to the command websocket handler
    property "endpoint", "string", "/ws"

    output_port "statistics", "gamepad_websocket/Statistics"

    periodic 0.1
end

# Takes raw command and publishes it via a websocket
task_context "RawCommandWebsocketPublisherTask",
             subclasses: "BaseWebsocketPublisherTask" do
    # How much time since the last raw_command sample before the commands are no longer
    # published to the websocket
    property "command_timeout", "base/Time"

    input_port "raw_command", "controldev/RawCommand"

    runtime_states :INPUT_TIMEOUT, :PUBLISHING

    exception_states :ID_MISMATCH
end
